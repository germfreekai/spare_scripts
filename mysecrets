#!/usr/bin/env zsh

# mysecrets
# store and read secrets, tokens and passwords
# for local use only
# base operation:
# assumed directory structure
# openssl aes-256-cbc -e -pbkdf2 -base64 -in <unencrypted_file> -k test -out <encrypted_file.enc>
# ~/.mysecrets
# ├── git_tokens
# │   └── git_token.enc
# └── secrets
#     └── secret.enc

RED="\e[31m"
BLUE="\e[36m"
GREEN="\e[32m"
RESET="\e[0m"

### Vars
SCRIPT_NAME=$(basename "${0}")

ROOT_DIR="${HOME}/.mysecrets"
GIT_TOKENS="${ROOT_DIR}/git_tokens"
SECRETS="${ROOT_DIR}/secrets"

GIT=false
SECRET=false

INPUT=""
OUT_FILE=""

PASSWD=""

ENCRYPT=false
DECRYPT=false
LIST=false

### Functions

# show usage
function show_help()
{
    cat << EOF
Usage: ${SCRIPT_NAME} [options]

OPTIONS:
    -g                    Git Tokens
    -s                    Secrets
CRYPTOGRAPHIC OPERATIONS:
    -e <file || string>   Encrypt
    -d <file || string>   Decrypt
    -k <passwd>           Encryption password 
OPTIONAL ARGUMENTS:
    -o <output>           Output file, if not given print to stdout
                          Will append .enc to resulting file name
    -l                    List available secrets

NOTE: For encrypt / decrypt operations, Git takes precedence if both options given
EOF
    exit 1
}

# Return path based on option.
# git takes precedence
function select_path()
{
    local git=${1}
    local secret=${2}
    
    local path=""

    if ${secret}; then
        path="${SECRETS}"
    fi
    if ${git}; then
        path="${GIT_TOKENS}"
    fi 
    
    echo "${path}"
}

# print files in path
function list_secrets() {
    local path="${1}"
    local vault_name="${2}"
   
    echo -e "${BLUE}[+] ${vault_name}${RESET}"
 
    # disable "no match" glob errors
    setopt NULL_GLOB

    local files=("${path}"/*)

    if (( ${#files[@]} == 0 )); then
        echo -e "${RED}[-] No files found${RESET}"
    else
        for file in "${files[@]}"; do
            [[ -e "$file" ]] || continue
            echo "- ${GREEN}${file:t}${RESET}"
        done
    fi

    unsetopt NULL_GLOB

    exit 0
}

# is it a file or a string
# returns 0 if true and 1 if false (shell)
function is_file()
{
    local input="${1}"

    [[ -f "${input}" ]]
}

# encrypt given input
function encrypt()
{
    local output_file_path="${1}"
    local psswd="${2}"
    local input="${3}"
    local output_file_name="${4}"

    local cmd="openssl aes-256-cbc -e -pbkdf2 -base64 -k ${psswd} "
    [[ -n "${output_file_name}" ]] && cmd+="-out ${output_file_path}/${output_file_name}.enc "

    if is_file "${input}"; then
        cmd+="-in ${input}"
    else
        cmd+="<<< \"${input}\""
    fi
   
    eval "${cmd}"
    res=$?

    if [[ ${res} -ne 0 ]]; then
        echo "${RED}[X] Failed${RESET}"
    else
        echo "${GREEN}[+] Success${RESET}"
    fi

}

function decrypt()
{
    local input_file_path="${1}"
    local psswd="${2}"
    local input="${3}"
    local output_file_name="${4}"

    local cmd="openssl aes-256-cbc -d -pbkdf2 -base64 -k ${psswd} "
    [[ -n "${output_file_name}" ]] && cmd+="-out ${output_file_name}.txt "

    if is_file "${input_file_path}/${input}"; then
        cmd+="-in ${input_file_path}/${input}"
    else
        cmd+="<<< \"${input}\""
    fi
 
    eval "${cmd}"
    res=$?

    if [[ ${res} -ne 0 ]]; then
        echo "${RED}[X] Failed${RESET}"
    else
        echo "${GREEN}[+] Success${RESET}"
    fi

}

### Main logic

while [[ $# -gt 0 ]];
do
    case "${1}" in
        -g)
            GIT=true
            shift;
            ;;
        -s)
            SECRET=true
            shift;
            ;;
        -e)
            if [[ -z "${2}" ]] || [[ "${2}" == -* ]]; then
                echo -e "${RED}[X] Encrypt argument requires an input file or string${RESET}"
                exit 1
            fi
            ENCRYPT=true
            DECRYPT=false
            INPUT="${2}"
            shift 2;
            ;;
        -d)
            if [[ -z "${2}" ]] || [[ "${2}" == -* ]]; then
                echo -e "${RED}[X] Decrypt argument requires an input file or string${RESET}"
                exit 1
            fi
            DECRYPT=true
            ENCRYPT=false
            INPUT="${2}"
            shift 2;
            ;;
        -o)
            if [[ -z "${2}" ]] || [[ "${2}" == -* ]]; then
                echo -e "${RED}[X] Missing output file${RESET}"
                exit 1
            fi
            OUT_FILE="${2}"
            shift 2;
            ;;
        -k)
            if [[ -z "${2}" ]] || [[ "${2}" == -* ]]; then
                echo -e "${RED}[X] Missing password${RESET}"
                exit 1
            fi
            PASSWD="${2}"
            shift 2;
            ;;
        -l)
            LIST=true
            shift;
            ;;
        *)
            show_help
    esac
done

# check optiont [git,secret]
if ! ${GIT} && ! ${SECRET}; then
    echo -e "${RED}[X] You need to select either GIT or SECRET${RESET}"
    exit 1
fi

S_PATH=$(select_path ${GIT} ${SECRET})

# list files?
if ${LIST}; then
    list_secrets "${S_PATH}" "${S_PATH:t}"
fi

# check for operation [encrypt,decrypt]
if ! ${ENCRYPT} && ! ${DECRYPT}; then
    echo -e "${RED}[X] Please specify an operation [encrypt,decrypt,list]${RESET}"
    exit 1
fi

if [[ -z "${PASSWD}" ]]; then
    echo -e "${RED}[X] Please provide the password for encrypt / decrypt operations${RESET}"
    exit 1
fi

if ${ENCRYPT}; then
    encrypt "${S_PATH}" "${PASSWD}" "${INPUT}" "${OUT_FILE}"
fi

if ${DECRYPT}; then
    decrypt "${S_PATH}" "${PASSWD}" "${INPUT}" "${OUT_FILE}"
fi

exit 0
